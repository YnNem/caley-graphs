""" ------------------Cayley graphs of permutation groups--------------------------------
Author: Yonatan Nemtsov

This program gives a method to draw Cayley graphs of finite groups.

A permutation is represented by a list. for example [0,2,1] coresponds to the
0->0, 1->2, 2->1 permutation.


"""
from math import factorial
import networkx as nx
import matplotlib.pyplot as plt

def permutation_prod(p,q):                    # Returns p o q.
    prod = []
    for i in q:
        prod.append(p[i])
    return prod

def S(n):                                     # Return Sn group as a list. Works for n<10 only!!
    if n == 1:
        return [[0]]
    Sn = []
    Sn_min_1 = S(n-1)

    for p in Sn_min_1:
        for i in range(n):
            pi = list(p)
            pi.insert(n-1-i,n-1)
            Sn.append(pi)
            
    return sorted(Sn)

def subgroup_gen_by(p):                     # Returns the subgroup generated by a permutation p.
    n = len(p)
    G = [p]
    q = p
    while q != [i for i in range(n)]:
        q = permutation_prod(q,p)
        G.append(q)
    return sorted(G)

def subgroup_gen_by_generators(generators):

    n = len(generators[0])
    I = [i for i in range(n)]
    S = [I]
    T = {1:I}
    
    while len(S)!=factorial(n):
        new_elements = []
        for i in T:
            s = T[i]
            for g in generators:
                k = permutation_prod(g,s)
                if not S.__contains__(k):
                    S.append(k)
                    new_elements.append([len(S),k])
        if new_elements == []:
            break
        T = {}
        for i in new_elements:
             T[i[0]] = i[1]
    return sorted(S)

def cycle_decomposition(permutation):
    pass

def find_subgroups_naive(group):
    G = sorted(group)
    subgroups = []
    H = G
    generators = []
    
    while H!= []:
        g = H[-1]
        generators.append(g)
        C = subgroup_gen_by(g)
        subgroups.append(C)
        for x in C:
            if H.__contains__(x):
                H.remove(x)

    T = True
    while T == True:
       pass    
        
        
    return subgroups


def cayley_graph(generators):
    n = len(generators[0])
    cayley_graph = nx.DiGraph()
    I = list(range(n))
    _S = [I]
    S = {1:I}
    T = {1:I}
    while len(S)!=factorial(n):
        new_elements = []
        for i in T:
            s = T[i]
            for g in generators:
                k = permutation_prod(g,s)
                if not _S.__contains__(k):
                    _S.append(k)
                    new_elements.append([len(_S),k])
        if new_elements == []:
            break
        T = {}
        for i in new_elements:
             S[i[0]] = i[1]
             T[i[0]] = i[1]
        print(T)
             
        
    for i in S:
        s = S[i]
        
        for g in generators:
            k = permutation_prod(s,g)
            cayley_graph.add_edge(i,_S.index(k)+1)
            
    return cayley_graph

def order(permutation):
    return len(subgroup_gen_by(permutation))


def draw_cayley_graph(generators):
    
    colors = ['blue','red','green','purple']
    G = cayley_graph(generators)
    edge_color = 1000*colors[:len(generators)]
    node_color = ['black']+(G.order()-1)*['blue']
    nx.draw(G,nx.kamada_kawai_layout(G),node_color = node_color, edge_color = edge_color)
    plt.show()



"""
#Examples

#example 1


draw_cayley_graph([[0,2,1,3],[1,3,2,0]])



#example 2

draw_cayley_graph([[1,0,2,3],[3,2,0,1]])

#example 3
S_5 = S(5)
for i in S_5:
    if order(i) == 3:
        for j in S_5:
            if order(j) == 2:
                draw_cayley_graph([i,j])


"""
